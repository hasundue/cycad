import { distinct } from "https://deno.land/std@0.204.0/collections/distinct.ts";
import $ from "https://deno.land/x/dax@0.35.0/mod.ts";

// Hard-ported from https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/tools/parsing/tree-sitter/default.nix
const LangOptions = {
  ocaml: { grammar: "ocaml", location: "ocaml" },
  "ocaml-interface": { grammar: "ocaml", location: "interface" },
  typescript: { grammar: "typescript", location: "typescript" },
  tsx: { grammar: "typescript", location: "tsx" },
  typst: { generate: true },
  markdown: { grammar: "markdown", location: "tree-sitter-markdown" },
  "markdown-inline": {
    grammar: "markdown",
    location: "tree-sitter-markdown-inline",
  },
  wing: { location: "libs/tree-sitter-wing", generate: true },
};

async function generateTypeDeclarationFile() {
  const langs = await fetch(
    `https://api.github.com/repos/NixOS/nixpkgs/contents/pkgs/development/tools/parsing/tree-sitter/grammars`,
  ).then(async (res) => {
    const json = await res.json() as { name: string }[];
    return distinct(
      json
        .filter((item) => item.name.endsWith(".json"))
        .map((item) =>
          item.name.replace(/^tree-sitter-/, "").replace(/\.json$/, "")
        )
        .concat(Object.keys(LangOptions)),
    ).sort();
  });

  const content = `
// Generated by src/langs.ts (do not edit manually)

export type Lang = ${langs.map((lang) => `"${lang}"`).join(" | ")}

export interface LangOption {
  grammar?: string;
  location?: string;
  generate?: boolean;
}

export const LangOptions: Partial<Record<Lang, LangOption>> = ${
    JSON.stringify(LangOptions)
  }`;

  await Deno.writeTextFile(
    new URL("./langs.generated.ts", import.meta.url),
    content,
  );
  $.cd(import.meta);
  await $`deno fmt ./langs.generated.ts`.stderr("null");
}

if (import.meta.main) {
  await generateTypeDeclarationFile();
  Deno.exit(0);
}
